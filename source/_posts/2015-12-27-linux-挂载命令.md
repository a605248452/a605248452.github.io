title: linux 挂载命令
author: Li Zhiyuan
tags:
  - Linux
categories:
  - Linux
date: 2015-12-27 16:24:57
---

## 挂载概念

Linux中的根目录以外的文件要想被访问，需要将其“关联”到根目录下的某个目录来实现，这种关联操作就是“挂载”，这个目录就是“挂载点”，解除次关联关系的过程称之为“卸载”。

注意：“挂载点”的目录需要以下几个要求：

1. 目录事先存在，可以用mkdir命令新建目录；

2. 挂载点目录不可被其他进程使用到；

3. 挂载点下原有文件将被隐藏。

<!-- more -->

## 挂载与卸载

挂载方法：`mount DECE MOUNT_POINT`

* mount：通过查看/etc/mtab（文章最后会对/etc/mtab有个解释）文件显示当前系统已挂载的所有设备

命令使用格式：`mount [-fnrsvw] [-t vfstype] [-o options] device dir`

device：指明要挂载的设备；

1. 设备文件：例如 `/dev/sda5`

2. 卷标：-L 'LABEL', 例如 -L 'MYDATA'

3. UUID, -U 'UUID'：例如 -U '0c50523c-43f1-45e7-85c0-a126711d406e'

4. 伪文件系统名称：proc, sysfs, devtmpfs, configfs

dir：挂载点

* 事先存在；建议使用空目录；

* 进程正在使用中的设备无法被卸载；

常用命令选项：

    -t vsftype：指定要挂载的设备上的文件系统类型；

    -r: readonly，只读挂载；

    -w: read and write, 读写挂载；

    -n: 不更新/etc/mtab； 

    -a：自动挂载所有支持自动挂载的设备；(定义在了/etc/fstab文件中，且挂载选项中有“自动挂载”功能)

    -L 'LABEL': 以卷标指定挂载设备；

    -U 'UUID': 以UUID指定要挂载的设备；

    -B, --bind: 绑定目录到另一个目录上；

    注意：查看内核追踪到的已挂载的所有设备：`cat /proc/mounts`

    -o options：(挂载文件系统的选项)

      async：异步模式；

      sync：同步模式；

      atime/noatime：包含目录和文件；

      diratime/nodiratime：目录的访问时间戳

      auto/noauto：是否支持自动挂载

      exec/noexec：是否支持将文件系统上应用程序运行为进程

      dev/nodev：是否支持在此文件系统上使用设备文件；

      suid/nosuid：是否支持在此文件系统上使用特殊权限

      remount：重新挂载

      ro：只读

      rw:读写

      user/nouser：是否允许普通用户挂载此设备

      acl：启用此文件系统上的acl功能

注意：**上述选项可多个同时使用，彼此使用逗号分隔**；

 默认挂载选项：defaults：rw, suid, dev, exec, auto, nouser, and async


## 命令演示：

1. 指定文件系统将块设备挂载至指定空文件夹内：演示内容：
   1. 没有指定文件系统，命令是否能正确执行；
   2. 指定错误文件系统，命令是否能正确执行；
   3. 挂载点有内容的文件夹，查看被挂载后其内容是否消失。

   ```shell script
   [root@localhost /]# fdisk -l
   ...
   设备 Boot      Start         End      Blocks   Id  System
   /dev/sdb1            2048     2099199     1048576   83  Linux
   /dev/sdb2         2099200     4196351     1048576    5  Extended
   /dev/sdb5         2101248     2306047      102400   83  Linux
   /dev/sdb6         2308096     2512895      102400   83  Linux
   /dev/sdb7         2514944     2719743      102400   83  Linux
   /dev/sdb8         2721792     2926591      102400   83  Linux
   ...
   [root@localhost /]# mount /dev/sdb8 /device
   [root@localhost /]# df
   文件系统                   1K-块    已用     可用 已用% 挂载点
   /dev/mapper/CentOS-root 18307072 4724136 13582936   26% /
   devtmpfs                  485368       0   485368    0% /dev
   tmpfs                     500664      84   500580    1% /dev/shm
   tmpfs                     500664    7160   493504    2% /run
   tmpfs                     500664       0   500664    0% /sys/fs/cgroup
   /dev/sda1                 508588  142620   365968   29% /boot
   tmpfs                     100136      20   100116    1% /run/user/42
   tmpfs                     100136       0   100136    0% /run/user/0
   /dev/sdb8                  98988    5280    93708    6% /device
   [root@localhost /]# blkid /dev/sdb8
   /dev/sdb8: UUID="a3c4bf06-3695-45e8-8a07-a063498f0578" TYPE="xfs" 
   [root@localhost /]# umount /device
   [root@localhost /]# mount -t ext2 /dev/sdb8 /device
   mount: 文件系统类型错误、选项错误、/dev/sdb8 上有坏超级块、
          缺少代码页或助手程序，或其他错误
   [root@localhost /]# cd /device/
   [root@localhost device]# ll
   总用量 0
   [root@localhost device]# touch 11 22
   [root@localhost device]# ll
   总用量 0
   -rw-r--r--. 1 root root 0 8月  23 10:14 11
   -rw-r--r--. 1 root root 0 8月  23 10:14 22
   [root@localhost device]# ll
   总用量 0
   [root@localhost device]# ll -a
   总用量 4
   drwxr-xr-x.  2 root root    6 8月  23 09:27 .
   dr-xr-xr-x. 21 root root 4096 8月  23 09:29 ..
   [root@localhost device]# cd ..
   [root@localhost /]# umount /device/
   [root@localhost /]# cd /device/
   [root@localhost device]# ll
   总用量 0
   -rw-r--r--. 1 root root 0 8月  23 10:14 11
   -rw-r--r--. 1 root root 0 8月  23 10:14 22
   ```
   通过上述演示，说明了如下事实： 
   1. 没有指定文件系统，块设备也可以正常挂载；
   2. 指定与块设备不一致的文件系统类型则命令报错；
   3. 挂载点有内容的文件夹，在挂载后内容消失，卸载后内容重现，也就是说挂载后会将原文件内容掩盖，但并不对其进行其他操作。
    
2. 演示内容：
   1. 指定卷标并以只读方式挂载；
   2. 对目录进行挂载操作，查看其与硬链接与软链接有何不同。

   ```shell script
   [root@localhost device]# blkid /dev/sdb6
   
   /dev/sdb6: LABEL="sdb6" UUID="8284450c-8cb9-45d7-a8b8-ed9ed9ef9e52" TYPE="xfs" 
   [root@localhost device]# mount -L 'sdb6' -r /device/ 
   [root@localhost device]# touch /device/33 
   touch: 无法创建"/device/33": 只读文件系统 
   [root@localhost device]# umount /device/ 
   [root@localhost /]# mount -B /etc/ /device/ 
   [root@localhost /]# ll -i / 
   总用量 64 
       11341 lrwxrwxrwx.  1 root root    7 7月  19 23:54 bin -> usr/bin
         128 dr-xr-xr-x.  4 root root 4096 8月  2 10:09 boot 
           3 drwxr-xr-x.  19 root root 3300 8月  23 09:10 dev 
    33554561 drwxr-xr-x. 129 root root 8192 8月  23 09:38 device 
    33554561 drwxr-xr-x. 129 root root 8192 8月  23 09:38 etc 
         158 drwxr-xr-x.  42 root root 4096 8月  22 09:00 home
   
   ```

   通过上述演示，说明了如下事实：
   1. 指定卷标挂载可行，以只读方式挂载后，无法对挂载点中的内容进行修改、创建等操作；
   2. 目录的挂载实质上是硬链接，挂载后可以对里面的文件内容进行修改与删除。
   
   注：**文件夹的挂载在df中并不显示**


## 卸载命令：umount

命令使用格式：

```shell script
umount DEVICE

umount MOUNT_POINT
```
   
上面已经演示过umount的使用

fuser：查看正在访问指定文件系统的进程：

命令使用格式：

```shell script
fuser -v MOUNT_POINT
```
终止所有在正访问指定的文件系统的进程：慎用

```shell script
fuser -km MOUNT_POINT
```

## 交换分区swap

这里介绍下交换分区，通过实验演示交换分区的创建及挂载

挂载交换分区：

启用：swapon

```shell script
   swapon [OPTION]... [DEVICE]
    # -a：激活所有的交换分区；
    # -p PRIORITY：指定优先级；
```
禁用：
```shell script
swapoff [OPTION]... [DEVICE]
```

实验演示：

1. 交换分区的创建：
   1. 新创建一分区，
   2. 修改新分区的类型，改为swap号码为82，
   3. 格式化为swap

    ```shell script
    [root@localhost ~]# fdisk /dev/sdb 
    欢迎使用 fdisk (util-linux 2.23.2)。 
    更改将停留在内存中，直到您决定将更改写入磁盘。 
    使用写入命令前请三思。 
    命令(输入 m 获取帮助)：n 
    Partition type: 
      p  primary (1 primary, 1 extended, 2 free) 
      l  logical (numbered from 5) 
    Select (default p): l 
    添加逻辑分区 9 
    起始 扇区 (2928640-4196351，默认为 2928640)： 
    将使用默认值 2928640 
    Last 扇区, +扇区 or +size{K,M,G} (2928640-4196351，默认为 4196351)：+100M 
    分区 9 已设置为 Linux 类型，大小设为 100 MiB 
    命令(输入 m 获取帮助)：p 
    磁盘 /dev/sdb：5368 MB, 5368709120 字节，10485760 个扇区 
    Units = 扇区 of 1 * 512 = 512 bytes 
    扇区大小(逻辑/物理)：512 字节 / 512 字节 
    I/O 大小(最小/最佳)：512 字节 / 512 字节 
    磁盘标签类型：dos 
    磁盘标识符：0xd391e822 
      设备 Boot      Start        End      Blocks  Id  System 
    /dev/sdb1            2048    2099199    1048576  83  Linux 
    /dev/sdb2        2099200    4196351    1048576    5  Extended 
    /dev/sdb5        2101248    2306047      102400  83  Linux 
    /dev/sdb6        2308096    2512895      102400  83  Linux 
    /dev/sdb7        2514944    2719743      102400  83  Linux 
    /dev/sdb8        2721792    2926591      102400  83  Linux 
    /dev/sdb9        2928640    3133439      102400  83  Linux 
    命令(输入 m 获取帮助)：t 
    分区号 (1,2,5-9，默认 9)：9 
    Hex 代码(输入 L 列出所有代码)：82 
    已将分区“Linux”的类型更改为“Linux swap / Solaris” 
    命令(输入 m 获取帮助)：p 
    磁盘 /dev/sdb：5368 MB, 5368709120 字节，10485760 个扇区 
    Units = 扇区 of 1 * 512 = 512 bytes 
    扇区大小(逻辑/物理)：512 字节 / 512 字节 
    I/O 大小(最小/最佳)：512 字节 / 512 字节 
    磁盘标签类型：dos 
    磁盘标识符：0xd391e822 
      设备 Boot      Start        End      Blocks  Id  System 
    /dev/sdb1            2048    2099199    1048576  83  Linux 
    /dev/sdb2        2099200    4196351    1048576    5  Extended 
    /dev/sdb5        2101248    2306047      102400  83  Linux 
    /dev/sdb6        2308096    2512895      102400  83  Linux 
    /dev/sdb7        2514944    2719743      102400  83  Linux 
    /dev/sdb8        2721792    2926591      102400  83  Linux 
    /dev/sdb9        2928640    3133439      102400  82  Linux swap / Solaris 
    命令(输入 m 获取帮助)：w 
    The partition table has been altered! 
    Calling ioctl() to re-read partition table. 
    正在同步磁盘。 
    [root@localhost ~]# mkswap /dev/sdb9 
    正在设置交换空间版本 1，大小 = 102396 KiB 
    无标签，UUID=74bf2766-a01b-48ea-9082-2fad6b8e06a9
    
    ```

2. 挂载交换分区：启用与禁用

    ```shell script
    [root@localhost ~]# free 
                  total        used        free      shared  buff/cache  available 
    Mem:        1001332      101756      535892      13424      363684      720328 
    Swap:      2097148          0    2097148 
    [root@localhost ~]# swapon /dev/sdb9  
    [root@localhost ~]# free 
                  total        used        free      shared  buff/cache  available 
    Mem:        1001332      101716      535924      13424      363692      720368 
    Swap:      2199544          0    2199544 
    [root@localhost ~]# swapoff /dev/sdb9  
    [root@localhost ~]# free 
                  total        used        free      shared  buff/cache  available 
    Mem:        1001332      102492      535152      13424      363688      719592 
    Swap:      2097148          0    2097148
    
    ```

实验涉及到的命令小结：    
  
* 内存空间使用状态：
    ```shell script
    free [OPTION]
        -m: 以MB为单位
        -g: 以GB为单位
    ```
* 文件系统空间占用等信息的查看工具：
    ```shell script
      df
        -h: human-readable
        -i: inodes instead of blocks
        -P: 以Posix兼容的格式输出; 
    ```
* 查看某目录总体空间占用状态：
    ```shell script
      du [OPTION]... DIR
        -h: human-readable
        -s: summary
    ```


命令总结：`mount, umount, free， df, du, swapon, swapoff, fuser`

## 开机自动挂载

如果我们想实现开机自动挂载某设备，只要修改 `/etc/fstab` 文件即可。

文件挂载的配置文件：`/etc/fstab`

查看此文件可知

每行定义一个要挂载的文件系统；

其每行的格式如下

```text
要挂载的设备或伪文件系统  挂载点  文件系统类型  挂载选项  转储频率  自检次序 
UUID=6efb8a23-bae1-427c-ab10-3caca95250b1 /boot  xfs    defaults    0 0

要挂载的设备或伪文件系统：设备文件、LABEL(LABEL="")、UUID(UUID="")、伪文件系统名称(proc, sysfs)

   挂载点：指定的文件夹

   挂载选项：defaults

   转储频率：
      0：不做备份
      1：每天转储
      2：每隔一天转储

   自检次序：
      0：不自检
      1：首先自检；一般只有rootfs才用1；
```

## /etc/fstab和/etc/mtab的区别

* /etc/fstab文件的作用: 

  记录了计算机上硬盘分区的相关信息，启动 Linux 的时候，检查分区的 fsck 命令，和挂载分区的 mount 命令，都需要 fstab 中的信息，来正确的检查和挂载硬盘。 

* /etc/mtab文件的作用： 

  记载的是现在系统已经装载的文件系统，包括操作系统建立的虚拟文件等；而/etc/fstab是系统准备装载的。 每当 mount 挂载分区、umount 卸载分区，都会动态更新 mtab，mtab 总是保持着当前系统中已挂载的分区信息，fdisk、df 这类程序，必须要读取 mtab 文件，才能获得当前系统中的分区挂载情况。当然我们自己还可以通过读取/proc/mount也可以来获取当前挂载信息 


 